; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=cahp -verify-machineinstrs < %s \
; RUN:   | FileCheck -check-prefix=CAHP %s

%struct.key_t = type { i16, [16 x i8] }

; FIXME: prologue and epilogue insertion must be implemented to complete this
; test

define i16 @test() nounwind {
; CAHP-LABEL: test:
; CAHP:       # %bb.0:
; CAHP-NEXT:	addi2	sp, -24
; CAHP-NEXT:	swsp	ra, 22(sp)
; CAHP-NEXT:	swsp	fp, 20(sp)
; CAHP-NEXT:	swsp	s0, 18(sp)
; CAHP-NEXT:	addi	fp, sp, 24
; CAHP-NEXT:	lsi	s0, 0
; CAHP-NEXT:	sw	s0, -16(fp)
; CAHP-NEXT:	sw	s0, -18(fp)
; CAHP-NEXT:	sw	s0, -20(fp)
; CAHP-NEXT:	sw	s0, -22(fp)
; CAHP-NEXT:	sw	s0, -24(fp)
; CAHP-NEXT:	lui	a0, %hi(test1)
; CAHP-NEXT:	addi	a1, a0, %lo(test1)
; CAHP-NEXT:	addi	a0, fp, -22
; CAHP-NEXT:	jalr	a1
; CAHP-NEXT:	mov	a0, s0
; CAHP-NEXT:	addi	sp, fp, -24
; CAHP-NEXT:	lwsp	s0, 18(sp)
; CAHP-NEXT:	lwsp	fp, 20(sp)
; CAHP-NEXT:	lwsp	ra, 22(sp)
; CAHP-NEXT:	addi2	sp, 24
; CAHP-NEXT:	jr	ra

  %key = alloca %struct.key_t, align 2
  %1 = bitcast %struct.key_t* %key to i8*
  call void @llvm.memset.p0i8.i64(i8* %1, i8 0, i64 10, i32 2, i1 false)
  %2 = getelementptr inbounds %struct.key_t, %struct.key_t* %key, i64 0, i32 1, i64 0
  call void @test1(i8* %2)
  ret i16 0
}

declare void @llvm.memset.p0i8.i64(i8* nocapture, i8, i64, i32, i1)

declare void @test1(i8*)
